import { Response, Request } from "express";
import { Booking } from "../models/bookingModel";
import { AuthenticationRequest } from "../middlewares/authMiddleware";
import { InternalServerError500, Success200 } from "../utils/responses";
import { logger } from "../utils/loggerUtils";
import mongoose from "mongoose";

/**
 * Retrieves revenue and ticket sales analytics for a specific event.
 *
 * This function performs an aggregation on the "bookings" collection to calculate:
 * - The total revenue generated by the event.
 * - The total number of tickets sold for the event.
 *
 * The aggregation involves:
 * - Joining the "bookings" collection with the "events" collection to fetch event details.
 * - Filtering bookings to include only those associated with the specified event ID.
 * - Grouping the filtered bookings by the event title.
 * - Calculating the total revenue and total ticket sales for the event.
 * - Projecting the results to include the event title, total revenue, and total ticket sales.

 */
export const eventRevenue = async (req: Request, res: Response) => {
  try {
    const revenue = await Booking.aggregate([
      {
        $lookup: {
          from: "events",
          foreignField: "_id",
          localField: "event",
          as: "eventDetails",
        },
      },
      {
        $unwind: "$eventDetails",
      },
      {
        $match: {
          "eventDetails._id": new mongoose.Types.ObjectId(req.params.id),
        },
      },
      {
        $group: {
          _id: "$eventDetails.title",
          totalRevenue: { $sum: "$totalPrice" },
          totalTicketSales: { $sum: "$numberOfTickets" },
        },
      },
      {
        $project: {
          _id: 1,
          totalRevenue: 1,
          totalTicketSales: 1,
        },
      },
    ]);

    return Success200(res, "_", revenue);
  } catch (error) {
    logger.error(error.message);
    return InternalServerError500(res, error);
  }
};

/**
 * Retrieves the most popular events based on ticket sales.
 *
 * This function performs an aggregation on the "bookings" collection to identify the top 4 events
 * with the highest ticket sales. The aggregation involves:
 * - Grouping bookings by event ID and summing the total number of tickets sold for each event.
 * - Sorting the grouped results in descending order of ticket sales.
 * - Limiting the results to the top 4 events.
 * - Fetching event details (e.g., title) by joining with the "events" collection.
 * - Projecting the results to include the event title and total ticket sales.
 *
 */
export const mostPopular = async (req: Request, res: Response) => {
  try {
    const mostPopular = await Booking.aggregate([
      {
        $group: {
          _id: "$event",
          totalTicketSales: { $sum: "$numberOfTickets" },
        },
      },
      {
        $sort: { totalTicketSales: -1 },
      },
      {
        $limit: 4,
      },
      {
        $lookup: {
          from: "events",
          foreignField: "_id",
          localField: "_id",
          as: "eventDetails",
        },
      },
      {
        $unwind: "$eventDetails",
      },

      {
        $project: {
          _id: 0,
          eventTitle: "$eventDetails.title",
          totalTicketSales: 1,
        },
      },
    ]);
    return Success200(res, "_", mostPopular);
  } catch (error) {
    logger.error(error.message);
    return InternalServerError500(res, error);
  }
};

/**
 * Retrieves the top three event categories based on ticket sales.
 *
 * This function performs an aggregation on the "bookings" collection to identify the top three
 * event categories with the highest ticket sales. The aggregation involves:
 * - Joining the "bookings" collection with the "events" collection to fetch event details.
 * - Grouping bookings by event category and summing the total number of tickets sold for each category.
 * - Sorting the grouped results in descending order of ticket sales.
 * - Limiting the results to the top three categories.
 * - Projecting the results to include the category name and total tickets sold.
 */

export const topThreeCategories = async (req: Request, res: Response) => {
  try {
    const topThreeCategories = await Booking.aggregate([
      {
        $lookup: {
          from: "events",
          foreignField: "_id",
          localField: "event",
          as: "eventDetails",
        },
      },
      { $unwind: "$eventDetails" },
      {
        $group: {
          _id: "$eventDetails.category",
          totalTicketsSold: { $sum: "$numberOfTickets" },
        },
      },
      { $sort: { totalTicketsSold: -1 } },
      { $limit: 3 },
      {
        $project: {
          _id: 1,
          totalTicketsSold: 1,
        },
      },
    ]);
    return Success200(res, "_", topThreeCategories);
  } catch (error) {
    logger.error(error.message);
    return InternalServerError500(res, error);
  }
};
